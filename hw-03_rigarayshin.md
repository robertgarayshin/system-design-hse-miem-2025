# Домашнее задание №3: Базы данных - Room With A View

## 1. Введение

На основе функциональных и нефункциональных требований из первой домашки и архитектуры из второй домашки необходимо определить подходящие базы данных для ключевых сервисов системы, их типы и роли, а также рассмотреть возможности репликации и шардинга.

## 2. Сценарии и выбор баз данных

| Сервис                         | Тип БД            | Обоснование выбора |
|-------------------------------|-------------------|--------------------|
| **Auth Service**              | PostgreSQL        | Реляционная модель, транзакции, устойчивое хранение пользовательских данных |
| **Reservation Service**       | PostgreSQL        | Транзакционная система с поддержкой ACID; сложные JOIN'ы, проверка коллизий при бронировании |
| **Room Management Service**   | PostgreSQL        | Сложные связи между комнатами, статусами и бронированиями; строгая консистентность |
| **Housekeeping Service**      | MongoDB           | Гибкая схема, возможность быстро добавлять новые поля в задачи персонала |
| **Notification Service**      | Redis + Kafka     | Redis - для хранения временных токенов и статусов; Kafka - для очередей уведомлений |
| **Smart Devices Integration** |  Redis  | Хранение телеметрии от устройств с высокой частотой обновлений; Redis для команд |
| **Feedback Service**          | MongoDB           | Неструктурированные отзывы, возможность быстрого поиска и агрегации |
| **Recommendation Service**    | Elasticsearch + PostgreSQL | Быстрый полнотекстовый поиск, аналитика по поведению; PostgreSQL для хранения истории |
| **Payment Gateway**   | Без БД            | Делегирует сохранение транзакций внешней системе |
| **Callcenter API**        | PostgreSQL        | Хранение заявок, логов, истории общения |


## 3. Репликация

### Цель:
Обеспечение отказоустойчивости, масштабируемости на чтение и высокой доступности данных

### Подходы:

- **PostgreSQL**:  
  - Синхронная репликация для критичных данных (бронь, аккаунты)  
  - Асинхронная репликация для аналитических запросов и резервного чтения (в том числе и потенциально для сервиса аналитики)

- **MongoDB**:  
  - Replica Set для автоматического failover и обеспечения отказоустойчивости

- **Redis**:  
  - Master-slave репликация для масштабируемости и надежности

- **Elasticsearch**:  
  - Встроенная репликация shard'ов для высокой доступности и скорости поиска

- **Kafka**:  
  - Встроенная репликация партиций для сохранности сообщений


## 4. Шардинг

### Цель:
Горизонтальное масштабирование при увеличении объема данных

### Подходы:

- **PostgreSQL**:  
  - Logical Sharding на уровне приложения по hotel_id (т.к отели независимы)

- **MongoDB**:  
  - Встроенный шардинг по user_id или hotel_id в зависимости от сервиса

- **Elasticsearch**:  
  - Автоматическое распределение данных по shard'ам с учетом размера индекса


## 5. Заключение

Нередки примеры, когда достаточно использования реляционной БД (например Postgres) для множества возложенных задач, особенно при небольших нагрузках. Однако в данном случае основной упор сделан на масштабируемость всей системы в целом, возможность резкого увеличения потока пользователей без ущерба производительности и общую надежность всей системы в целом. Исходя из такого подхода был сделан следующий выбор. Транзакционные операции — PostgreSQL, очереди — Kafka, уведомления/команды — Redis. Репликация и шардинг спроектированы с учетом высокой нагрузки в сезон, необходимости отказоустойчивости и быстрого отклика.
